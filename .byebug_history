c
week_differential
week_calories
week_calories[0][1] = 'fart'
week_calories
week_differential
c
a = week_calories.dup
week_calories.map { |a| a[1].to_i }
week_differential.map { |a| a[1].to_i }
week_differential
c
@week_calories.map { |a| a[1].to_i }
@week_calories.count
@week_calories[0][1]
@week_calories
c
@dashboard_data[:week_averages]
@dashboard_data
@week_in_review
exit
activities.first.day
day[1]
today
exit
c
day[1].to_i
day[1]
activity.calories
today
exit
c
activity
c
activities
c
tdee
atdee
c
weights
calories
c
calories.count
weights.count
weights
c
tdee
week_differential
c
activities
c
activities.to_a
activities
actuvutues
c
typof
date.type
date.strftime('%Y')
Date.parse(date)
date
exit 1
c
routine.last_completed
routine
c
exit 1
n
cookies[:add_to_recipe]
cookies
n
params[:recipe]
c
cookies[:add_to_recipe]
exit
food.measurements.first.errors
food.measurements.first
food.measurements.count
food.measurements
food.errors
food.save
food
exit 1
Food.count
Food.where(ndbno: ndbno).first
Food.where(ndbno: ndbno).count
Food.where(ndbno: ndbno)
ndbno
food
c
puts "hi" if food.nil?
if food.nil? p "hi" end;
if food.nil? p "hi" end
if food.nil?
food
exit
continue
disable breakpoints
disable
finish
help
c
food.nil?
food
exit 1
foods.delete_if { |key, food| food["measurements"].count == 0 }
foods.delete_if { |key, food| food.measurements.count == 0 }
foods.reject { |food| food.measurements.count > 0 }
foods.filter { |food| food.measurements.count > 0 }
foods.first
foods
exit
exit 1
c
ndbno
report
exit
next
report
c
foods.first
foods.pop
foods[0]
foods
quit
help
?
c
data
c
data
ndbno
c
nutrition
weights
c
macros["208"]
macros = macros.stringify_keys
macros = macros.stringfy_keys
macro = macro.stringfy_keys
macros
macros["208"]
macros[208]
nutrition
c
report["measurements"]
measurements
c
measurements
c
measurement
c
measurement["unit"]
measurement
c
report["measurements"]["1.0cup, diced"]["unit"]
report["measurements"]["1.0cup, diced"]
report["measurements"]
report
c
report
c
r
report
c
r
report
c
report
c
report
c
a.count
c
a
c
ndbnos
c
@foods.unshift
@foods.pop
@foods
c
response.body
response_contains "/log/" + new_measurement_id.to_s
response_contains "/log//" + new_measurement_id
food_entry_add_food_path(current_day, new_measurement_id)
food_entry_add_food_path
current_day
c
new_id
a = Food.find(new_food_id).measurements.count
a = Food.find(new_food_id).measurements
a = Food.find(new_food_id)
new_food_id
exit
para,
c
exit
parameters.each do |param| puts param end
parameters.each do |param| puts param; end;
parameters.each do |param| puts param
parameters.each do |param|
c
exit
response.body.to_s
response.body
response
response.body()
response
c
params[:measurement]['0']
params[:measurement][0]
params[:measurement]
c
params[:measurement]
params
c
current_day
last_entry
c
last_entry
last_day
exit
c
food.measurements.to_a.count
food.measurements.to_a
food.measurements.count
food.measurements.number.count
food.measurements.number
food.measurements
c
@user.pt_messages.where(seen: false).count
CronDeliverReminderMessagesJob.perform_now
@user.pt_messages.where(seen: false).count
c
@user.pt_messages
c
n
exit
existing.nil?
existing
n
c
n
user.preferences["auto_faturdays"]
c
user.preferences["auto_faturdays"]
day_token
c
n
user.preferences["auto_faturdays"]
c
user.preferences["auto_faturdays"]["mo"]
user.preferences["auto_faturdays"]
c
params[:activity]["muscle_groups"]
params[:activity][:muscle_groups]
